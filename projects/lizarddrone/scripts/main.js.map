{"version":3,"names":[],"mappings":"","sources":["main.js"],"sourcesContent":["function buildStageModifier(canvas) {\n  var worldWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var worldHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var retina = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var ctx = canvas.getContext('2d');\n  var worldRatio = worldWidth / worldHeight;\n  var retinaScale = typeof retina === 'boolean' ? retina ? 2 : 1 : retina;\n  var sprytCanvas = {\n    ctx: ctx,\n    canvas: canvas,\n    resizeCanvas: resizeCanvas,\n    offsetToStageX: offsetToStageX,\n    offsetToStageY: offsetToStageY,\n    scaleToStage: scaleToStage,\n\n    get stageWidth() {\n      return stageWorldWidth;\n    },\n    get stageHeight() {\n      return stageWorldHeight;\n    },\n\n    get worldOffsetX() {\n      return stageWorldOffsetX;\n    },\n    get worldOffsetY() {\n      return stageWorldOffsetY;\n    }\n  };\n\n  var offsetX = void 0;\n  var offsetY = void 0;\n  var stageWidth = void 0;\n  var stageHeight = void 0;\n  var stageScale = void 0;\n  var windowWidth = void 0;\n  var windowHeight = void 0;\n  var stageWorldWidth = void 0;\n  var stageWorldHeight = void 0;\n  var stageWorldOffsetX = void 0;\n  var stageWorldOffsetY = void 0;\n\n  return sprytCanvas;\n\n  function getIdealSprytCanvasSize(windowWidth, windowHeight) {\n    stageWidth = windowWidth;\n    stageHeight = windowWidth / worldRatio;\n    stageScale = stageHeight / worldHeight;\n\n    if (stageHeight > window.innerHeight) {\n      stageWidth = windowHeight * worldRatio;\n      stageHeight = windowHeight;\n      stageScale = stageWidth / worldWidth;\n    }\n\n    offsetX = (windowWidth - stageWidth) / 2 * retinaScale;\n    offsetY = (windowHeight - stageHeight) / 2 * retinaScale;\n\n    stageWidth *= retinaScale;\n    stageHeight *= retinaScale;\n    stageWorldWidth = windowWidth / stageScale;\n    stageWorldHeight = windowHeight / stageScale;\n    stageWorldOffsetX = offsetX / stageScale;\n    stageWorldOffsetY = offsetY / stageScale;\n\n    return { stageScale: stageScale, stageWidth: stageWidth, stageHeight: stageHeight, offsetX: offsetX, offsetY: offsetY };\n  }\n\n  function resizeCanvas() {\n    windowWidth = window.innerWidth;\n    windowHeight = window.innerHeight;\n\n    getIdealSprytCanvasSize(windowWidth, windowHeight);\n\n    canvas.width = windowWidth * retinaScale;\n    canvas.height = windowHeight * retinaScale;\n  }\n\n  function offsetToStageX(x) {\n    return x * stageScale * retinaScale + offsetX;\n  }\n\n  function offsetToStageY(y) {\n    return y * stageScale * retinaScale + offsetY;\n  }\n\n  function scaleToStage(s) {\n    return s * stageScale * retinaScale;\n  }\n}\n\nfunction buildStageCtx() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var resize = _ref.resize;\n  var canvas = _ref.canvas;\n  var ctx = _ref.ctx;\n  var offsetToStageX = _ref.offsetToStageX;\n  var offsetToStageY = _ref.offsetToStageY;\n  var scaleToStage = _ref.scaleToStage;\n\n  var newCtx = {\n    fillRect: fillRect,\n    drawImage: drawImage,\n    drawImagePart: drawImagePart,\n    rotate: rotate,\n    translate: translate,\n    save: save,\n    restore: restore,\n    createLinearGradient: createLinearGradient,\n    fillText: fillText,\n    font: font,\n\n    _: ctx,\n\n    set fillStyle(val) {\n      ctx.fillStyle = val;\n    },\n    get fillStyle() {\n      return ctx.fillStyle;\n    }\n  };\n\n  return newCtx;\n\n  function fillRect(x, y, width, height) {\n    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n    if (offset) {\n      return ctx.fillRect(offsetToStageX(x), offsetToStageY(y), scaleToStage(width), scaleToStage(height));\n    }\n    return ctx.fillRect(scaleToStage(x), scaleToStage(y), scaleToStage(width), scaleToStage(height));\n  }\n\n  function clearRect(x, y, width, height) {\n    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n    if (offset) {\n      return ctx.clearRect(offsetToStageX(x), offsetToStageY(y), scaleToStage(width), scaleToStage(height));\n    }\n    return ctx.clearRect(scaleToStage(x), scaleToStage(y), scaleToStage(width), scaleToStage(height));\n  }\n\n  function drawImage(image, dx, dy, dWidth, dHeight) {\n    var offset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (offset) {\n      return ctx.drawImage(image, offsetToStageX(dx), offsetToStageY(dy), scaleToStage(dWidth), scaleToStage(dHeight));\n    }\n    return ctx.drawImage(image, scaleToStage(dx), scaleToStage(dy), scaleToStage(dWidth), scaleToStage(dHeight));\n  }\n\n  function drawImagePart(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\n    var offset = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : true;\n\n    if (offset) {\n      return ctx.drawImage(image, sx, sy, sWidth, sHeight, offsetToStageX(dx), offsetToStageY(dy), scaleToStage(dWidth), scaleToStage(dHeight));\n    }\n    return ctx.drawImage(image, sx, sy, sWidth, sHeight, scaleToStage(dx), scaleToStage(dy), scaleToStage(dWidth), scaleToStage(dHeight));\n  }\n\n  function rotate(deg) {\n    return ctx.rotate(deg);\n  }\n\n  function translate(x, y) {\n    return ctx.translate(offsetToStageX(x), offsetToStageY(y));\n  }\n\n  function createLinearGradient(x0, y0, x1, y1) {\n    return ctx.createLinearGradient(scaleToStage(x0), scaleToStage(y0), scaleToStage(x1), scaleToStage(y1));\n  }\n\n  function save() {\n    return ctx.save();\n  }\n\n  function restore() {\n    return ctx.restore();\n  }\n\n  function fillText(text, x, y) {\n    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (offset) {\n      return ctx.fillText(text, offsetToStageX(x), offsetToStageY(y));\n    }\n    return ctx.fillText(text, scaleToStage(x), scaleToStage(y));\n  }\n\n  function font(size, text) {\n    return ctx.font = scaleToStage(size) + \"px \" + text;\n  }\n}\n\nvar canvasElement = document.getElementById('spryt-stage');\nvar stageWidth = 9;\nvar stageHeight = 15;\nvar retinaScale = window.devicePixelRatio;\n\nvar stageTools = buildStageModifier(canvasElement, stageWidth, stageHeight, retinaScale);\nvar stageCtx = buildStageCtx(stageTools);\n\nvar stage = {\n  tools: stageTools,\n  ctx: stageCtx,\n  canvas: canvasElement,\n  width: stageWidth,\n  height: stageHeight\n};\n\nvar squareWidth = 1.5;\nvar squareHeight = squareWidth * 1;\nvar jumpPower = 0.4;\nvar sideSpeed = 0.1;\nvar gravity = 0.02;\nvar bounceFriction = 0.5;\nvar airResistance = 0.99;\nvar settleSpeed = 0.1;\nvar rotationFunction = function rotationFunction(y) {\n  return Math.max(-0.1, Math.min(0.3, y * 0.8));\n};\n\nvar pos = {};\nvar speed = {\n  x: 0,\n  y: 0\n};\nvar size = {\n  width: squareWidth,\n  height: squareHeight\n};\nvar controls = {\n  ArrowUp: {\n    down: jump,\n    up: function up() {}\n  },\n\n  ArrowRight: {\n    down: function down() {\n      speed.x = sideSpeed;\n    },\n    up: function up() {\n      speed.x = 0;\n    }\n  },\n\n  ArrowLeft: {\n    down: function down() {\n      speed.x = -sideSpeed;\n    },\n    up: function up() {\n      speed.x = 0;\n    }\n  }\n};\nvar firstRun = true;\nvar control = {\n  sim: sim,\n  init: init$1,\n  pos: pos,\n  size: size\n};\n\nwindow.addEventListener('keydown', function (e) {\n  if (controls[e.code]) {\n    e.preventDefault();\n    keyDown(e.code);\n  }\n});\n\nwindow.addEventListener('keyup', function (e) {\n  if (controls[e.code]) {\n    e.preventDefault();\n    keyUp(e.code);\n  }\n});\n\nwindow.addEventListener('mousedown', jump);\nwindow.addEventListener('touchstart', jump);\n\nfunction sim(stage) {\n  if (firstRun) {\n    init$1(stage);\n    firstRun = false;\n  } else {\n    simUnit(stage);\n  }\n}\n\nfunction init$1(stage) {\n  pos.x = squareWidth * 1.5;\n  pos.y = stage.height / 2;\n}\n\nfunction keyUp(code) {\n  controls[code].up && controls[code].up();\n}\n\nfunction keyDown(code) {\n  controls[code].down && controls[code].down();\n}\n\nfunction jump(e) {\n  e && e.preventDefault();\n  speed.y = -jumpPower;\n}\n\nfunction simUnit(stage) {\n  if (speed.x) {\n    pos.x += speed.x;\n\n    if (pos.x < squareWidth / 2) {\n      pos.x = squareWidth / 2;\n    } else if (pos.x > stage.width - squareWidth / 2) {\n      pos.x = stage.width - squareWidth / 2;\n    }\n  }\n\n  pos.y += speed.y;\n  speed.y = (speed.y + gravity) * airResistance;\n\n  if (pos.y < squareHeight / 2) {\n    speed.y *= -bounceFriction;\n    pos.y = squareHeight / 2;\n  } else if (pos.y >= stage.height - squareHeight / 2) {\n    speed.y = Math.abs(speed.y) > settleSpeed ? speed.y * -bounceFriction : 0;\n    pos.y = stage.height - squareHeight / 2;\n  }\n\n  pos.rot = rotationFunction(speed.y);\n}\n\nvar userName = localStorage.getItem('mokoDroneUsername') || prompt('Enter your username!', '');\nvar highScore = localStorage.getItem('mokoDroneHiscore') ? +localStorage.getItem('mokoDroneHiscore') : 0;\nlocalStorage.setItem('mokoDroneUsername', userName);\n\nvar sendScore = function (newHighscore) {\n  if (newHighscore > +highScore) {\n    localStorage.setItem('mokoDroneHiscore', newHighscore);\n    var data = {\n      text: userName + ' just got a new highscore of ' + newHighscore + '! <https://brook.dev/tg/moko|Try beat them.>'\n    };\n\n    var oReq = new XMLHttpRequest();\n    oReq.open('POST', 'https://hooks.slack.com/services/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');\n    oReq.send(JSON.stringify(data));\n\n    highScore = newHighscore;\n  }\n}\n\nvar blocks = [];\nvar blockWidth = 1;\nvar blockSpacing = 6;\nvar gapsize = 4.5;\nvar gapHeightMin = 4;\nvar gapHeightMax = 11;\n\nvar score = {\n  current: 0,\n  high: 0\n};\n\nvar simRunning = true;\nvar insideGap = false;\nvar insideGapPreviously = insideGap;\n\nvar blocks$1 = {\n  sim: controlBlocks,\n  blocks: blocks,\n  score: score,\n  pause: pauseSim,\n  restart: restartSim\n};\n\nfunction controlBlocks(stage, moko) {\n  if (simRunning) {\n    while (!blocks.length || blocks[blocks.length - 1].x < stage.tools.stageWidth - blockSpacing) {\n      newBlock(stage);\n    }\n\n    for (var i = 0, l = blocks.length; i < l; l += 1) {\n      if (blocks[i].x < -stage.tools.worldOffsetX - blockWidth) {\n        blocks.shift();\n      } else {\n        break;\n      }\n    }\n\n    insideGapPreviously = insideGap;\n    insideGap = false;\n    blocks.forEach(function (block) {\n      return collideBlock(block, moko);\n    });\n    if (insideGapPreviously && !insideGap) {\n      score.current += 1;\n    }\n  } else if (!blocks.length) {\n    restartSim();\n  } else {\n    insideGapPreviously = false;\n    insideGap = false;\n    if (score.current > score.high) {\n      score.high = score.current;\n      sendScore(score.high);\n    }\n    score.current = 0;\n    blocks.forEach(function (block) {\n      return block.opening = block.opening || Math.random() * 0.5 + 0.3;\n    });\n  }\n\n  blocks.forEach(function (block) {\n    return controlBlock(block, stage);\n  });\n}\n\nfunction controlBlock(block, stage) {\n  block.x -= 0.1;\n  if (block.opening) {\n    block.gap += block.opening;\n    block.opening *= 1.5;\n    if (block.gap > stage.height * 2) {\n      blocks.splice(blocks.indexOf(block), 1);\n    }\n  }\n}\n\nfunction collideBlock(block, moko) {\n  //  Inside a gap\n  if (block.x < moko.pos.x + 0.5 && block.x > moko.pos.x - moko.size.width / 4 - 0.5) {\n    insideGap = true;\n    //  Hit the top block\n    if (moko.pos.y - moko.size.height / 4 < block.height - block.gap / 2) {\n      pauseSim();\n      return true;\n    }\n    //  Hit the bottom block\n    if (moko.pos.y + moko.size.height / 4 > block.height + block.gap / 2) {\n      pauseSim();\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction newBlock(stage) {\n  var lastBlock = blocks[blocks.length - 1];\n  blocks.push({\n    x: lastBlock ? lastBlock.x + blockSpacing : stage.tools.stageWidth,\n    width: blockWidth,\n    height: Math.random() * (gapHeightMax - gapHeightMin) + gapHeightMin,\n    gap: gapsize,\n    opening: false\n  });\n}\n\nfunction pauseSim() {\n  simRunning = false;\n}\n\nfunction restartSim() {\n  simRunning = true;\n}\n\nfunction renderSquare(stage, image, width, height, x, y) {\n  var rotate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  stage.ctx.save();\n  stage.ctx.translate(x, y);\n  stage.ctx.rotate(rotate);\n  stage.ctx.drawImage(image, -width / 2, -height / 2, width, height, false);\n  stage.ctx.restore();\n}\n\n//let gradPoint = (Math.random() * 0.2) + 0.2;\n\nfunction renderBounds(stage) {\n  //const gradient = stage.ctx._.createLinearGradient(0, 0, stage.canvas.width * gradPoint, stage.canvas.height);\n  //if (Math.random() > 0.99) { gradPoint = (Math.random() * 0.1) + 0.25; }\n  //gradient.addColorStop(0, \"#332b28\");\n  //gradient.addColorStop(gradPoint, \"#4a4547\");\n  //gradient.addColorStop(1, \"#332b28\");\n  //stage.ctx.fillStyle = gradient;\n  stage.ctx.fillStyle = '#4b4547';\n  stage.ctx._.fillRect(0, 0, stage.canvas.width, stage.canvas.height, false);\n}\n\nfunction renderBlocks(stage, blocks, topImage, bottomImage) {\n  blocks.blocks.forEach(function (block) {\n    return renderBlock(block, stage, topImage, bottomImage, blocks.score);\n  });\n}\n\nfunction renderBlock(block, stage, topImage, bottomImage, score) {\n  var gapTop = block.height - block.gap / 2;\n  var blockHeight = block.width * 8;\n  stage.ctx.drawImage(topImage, block.x, gapTop - blockHeight, block.width, blockHeight);\n  stage.ctx.drawImage(bottomImage, block.x, block.height + block.gap / 2, block.width, blockHeight);\n\n  stage.ctx.fillStyle = '#3a302c';\n  stage.ctx.font(1, \"'Open Sans', sans-serif\");\n  stage.ctx.fillText(\"\" + score.current, 0.4, 1.2, false);\n  stage.ctx.font(0.5, \"'Open Sans', sans-serif\");\n  stage.ctx.fillText(\"Hi-Score: \" + score.high, 0.4, 2.2, false);\n}\n\n/**\n*  @typedef thread\n*  @type {Object}\n*\n*  @property {number}   fps      - The number of times this threads' tasks run every second\n*  @property {boolean}  active   - Whether or not this thread should currently be running its tasks\n*  @property {array}    tasks    - An array of functions, or 'tasks', this thread will run every 'tick'\n*/\n\n/**\n*  Returns a threadRunner object. This is used for running 'simulations', or 'multi-run-functions' a certain number of times per second in a way which setTimeout cannot guarantee.\n*  @function\n*  @name createThreadRunner\n*  @returns {threadRunner} threadRunner\n*/\n\nvar activeThreads = {};\nvar idleThreads = {};\nvar threadRunner = {\n  addThread: addThread,\n  __activeThreads: activeThreads,\n  __idleThreads: idleThreads\n};\n\nvar uuid = 0;\ntick();\n\nfunction tick() {\n  for (var i in activeThreads) {\n    activeThreads[i].run();\n  }\n\n  requestAnimationFrame(tick);\n}\n\nfunction addThread() {\n  var newThreadID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ++uuid;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (activeThreads[newThreadID] || idleThreads[newThreadID]) {\n    throw new Error('Thread with ID ' + newThreadID + ' already exists.');\n  }\n  var thread = new Thread(newThreadID, options);\n  activeThreads[newThreadID] = thread;\n  return thread;\n}\n\nfunction Thread(id) {\n  var _this = this;\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref$fps = _ref.fps;\n  var fps = _ref$fps === undefined ? 60 : _ref$fps;\n  var _ref$active = _ref.active;\n  var active = _ref$active === undefined ? false : _ref$active;\n  var _ref$tasks = _ref.tasks;\n  var tasks = _ref$tasks === undefined ? [] : _ref$tasks;\n  var _ref$frame = _ref.frame;\n  var frame = _ref$frame === undefined ? 0 : _ref$frame;\n  var _ref$simulate = _ref.simulate;\n  var simulate = _ref$simulate === undefined ? true : _ref$simulate;\n\n  var atTime = +new Date();\n  this.id = id;\n\n  this.resetFrame = function () {\n    frame = 0;\n  };\n\n  this.destroy = function () {\n    delete activeThreads[id];\n  };\n\n  this.play = function () {\n    atTime = +new Date();\n    activeThreads[id] = _this;\n    delete idleThreads[id];\n  };\n\n  this.pause = function () {\n    idleThreads[id] = _this;\n    delete activeThreads[id];\n  };\n\n  this.addTask = function (task) {\n    if (tasks.indexOf(task) === -1) {\n      tasks.push(task.bind(_this));\n    }\n  };\n\n  this.removeTask = function (task) {\n    var taskIndex = tasks.indexOf(task);\n    if (taskIndex > -1) {\n      tasks.splice(taskIndex, 1);\n    }\n  };\n\n  this.run = function () {\n    var dateNow = +new Date();\n\n    if (!simulate || atTime < dateNow) {\n      tasks.forEach(function (task) {\n        task();\n      });\n\n      atTime += 1000 / fps;\n      frame += 1;\n\n      if (simulate) {\n        _this.run();\n      }\n    }\n  };\n\n  Object.defineProperty(this, 'frame', {\n    get: function get() {\n      return frame;\n    },\n    set: function set(value) {\n      return frame;\n    }\n  });\n}\n\nvar simThread = threadRunner.addThread('sim-thread', { fps: 60 });\nvar renderThread = threadRunner.addThread('render-thread', { fps: 10, simulate: false });\nvar renderQueue = [function () {\n  return renderBounds(stage);\n}, function () {\n  return renderBlocks(stage, blocks$1, images.lamp, images.crates);\n}];\nvar imageURLs = [['mokoCopter', 'https://brook.dev/projects/lizarddrone/images/lizard-copter.png'], ['lamp', 'https://brook.dev/projects/lizarddrone/images/lamp.png'], ['crates', 'https://brook.dev/projects/lizarddrone/images/crates.png']];\nvar images = {};\n\nloadImages().then(init);\n\nfunction init() {\n  renderThread.addTask(render);\n  renderQueue.push(function () {\n    return renderSquare(stage, images.mokoCopter, control.size.width, control.size.height, control.pos.x, control.pos.y, control.pos.rot);\n  });\n  stage.tools.resizeCanvas();\n  control.init(stage);\n\n  window.addEventListener('resize', stage.tools.resizeCanvas);\n\n  window.addEventListener('touchstart', addSim);\n  window.addEventListener('mousedown', addSim);\n  window.addEventListener('keydown', addSim);\n}\n\nfunction loadImages() {\n  var imagesLoaded = 0;\n\n  return new Promise(function (resolve, reject) {\n    imageURLs.forEach(function (image) {\n      var img = new Image();\n      img.onload = function () {\n        imagesLoaded += 1;\n        if (imagesLoaded === imageURLs.length) {\n          resolve();\n        }\n      };\n      img.src = image[1];\n      images[image[0]] = img;\n    });\n  });\n}\n\nfunction render() {\n  renderQueue.forEach(function (renderQueueItem) {\n    renderQueueItem();\n  });\n}\n\nfunction addSim() {\n  window.removeEventListener('touchstart', addSim);\n  window.removeEventListener('mousedown', addSim);\n  window.removeEventListener('keydown', addSim);\n  simThread.addTask(controlSim);\n  setTimeout(function () {\n    return simThread.addTask(function () {\n      return blocks$1.sim(stage, control);\n    });\n  }, 0);\n}\n\nfunction controlSim() {\n  control.sim(stage);\n}\n"],"file":"main.js","sourceRoot":"/source/"}
